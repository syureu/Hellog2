{"ast":null,"code":"/*\n * Copyright 2016 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n * use this file except in compliance with the License. You may obtain a copy of\n * the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations under\n * the License.\n */\nmodule.exports = function proxyPolyfill() {\n  let lastRevokeFn = null;\n  let ProxyPolyfill;\n  /**\n   * @param {*} o\n   * @return {boolean} whether this is probably a (non-null) Object\n   */\n\n  function isObject(o) {\n    return o ? typeof o === 'object' || typeof o === 'function' : false;\n  }\n\n  function validateProto(proto) {\n    if (proto !== null && !isObject(proto)) {\n      throw new TypeError('Object prototype may only be an Object or null: ' + proto);\n    }\n  }\n\n  const $Object = Object; // Closure assumes that `{__proto__: null} instanceof Object` is always true, hence why we check against a different name.\n\n  const canCreateNullProtoObjects = Boolean($Object.create) || !({\n    __proto__: null\n  } instanceof $Object);\n  const objectCreate = $Object.create || (canCreateNullProtoObjects ? function create(proto) {\n    validateProto(proto);\n    return {\n      __proto__: proto\n    };\n  } : function create(proto) {\n    validateProto(proto);\n\n    if (proto === null) {\n      throw new SyntaxError('Native Object.create is required to create objects with null prototype');\n    } // nb. cast to convince Closure compiler that this is a constructor\n\n\n    var T =\n    /** @type {!Function} */\n    function T() {};\n\n    T.prototype = proto;\n    return new T();\n  });\n\n  const noop = function () {\n    return null;\n  };\n\n  const getProto = $Object.getPrototypeOf || ([].__proto__ === Array.prototype ? function getPrototypeOf(O) {\n    // If O.[[Prototype]] === null, then the __proto__ accessor won't exist,\n    // as it's inherited from `Object.prototype`\n    const proto = O.__proto__;\n    return isObject(proto) ? proto : null;\n  } : noop);\n  /**\n   * @constructor\n   * @param {!Object} target\n   * @param {{apply, construct, get, set}} handler\n   */\n\n  ProxyPolyfill = function (target, handler) {\n    const newTarget = this && this instanceof ProxyPolyfill ? this.constructor : undefined;\n\n    if (newTarget === undefined) {\n      throw new TypeError(\"Constructor Proxy requires 'new'\");\n    }\n\n    if (!isObject(target) || !isObject(handler)) {\n      throw new TypeError('Cannot create proxy with a non-object as target or handler');\n    } // Construct revoke function, and set lastRevokeFn so that Proxy.revocable can steal it.\n    // The caller might get the wrong revoke function if a user replaces or wraps scope.Proxy\n    // to call itself, but that seems unlikely especially when using the polyfill.\n\n\n    let throwRevoked = function () {};\n\n    lastRevokeFn = function () {\n      /** @suppress {checkTypes} */\n      target = null; // clear ref\n\n      throwRevoked = function (trap) {\n        throw new TypeError(`Cannot perform '${trap}' on a proxy that has been revoked`);\n      };\n    };\n\n    setTimeout(function () {\n      lastRevokeFn = null;\n    }, 0); // Fail on unsupported traps: Chrome doesn't do this, but ensure that users of the polyfill\n    // are a bit more careful. Copy the internal parts of handler to prevent user changes.\n\n    const unsafeHandler = handler;\n    handler = {\n      'get': null,\n      'set': null,\n      'apply': null,\n      'construct': null\n    };\n\n    for (let k in unsafeHandler) {\n      if (!(k in handler)) {\n        throw new TypeError(`Proxy polyfill does not support trap '${k}'`);\n      }\n\n      handler[k] = unsafeHandler[k];\n    }\n\n    if (typeof unsafeHandler === 'function') {\n      // Allow handler to be a function (which has an 'apply' method). This matches what is\n      // probably a bug in native versions. It treats the apply call as a trap to be configured.\n      handler.apply = unsafeHandler.apply.bind(unsafeHandler);\n    } // Define proxy as an object that extends target.[[Prototype]],\n    // or a Function (if either it's callable, or apply is set).\n\n\n    const proto = getProto(target); // can return null in old browsers\n\n    let proxy;\n    let isMethod = false;\n    let isArray = false;\n\n    if (typeof target === 'function') {\n      proxy = function ProxyPolyfill() {\n        const usingNew = this && this.constructor === proxy;\n        const args = Array.prototype.slice.call(arguments);\n        throwRevoked(usingNew ? 'construct' : 'apply'); // TODO(samthor): Closure compiler doesn't know about 'construct', attempts to rename it.\n\n        if (usingNew && handler['construct']) {\n          return handler['construct'].call(this, target, args);\n        } else if (!usingNew && handler.apply) {\n          return handler['apply'](target, this, args);\n        } // since the target was a function, fallback to calling it directly.\n\n\n        if (usingNew) {\n          // inspired by answers to https://stackoverflow.com/q/1606797\n          args.unshift(target); // pass class as first arg to constructor, although irrelevant\n          // nb. cast to convince Closure compiler that this is a constructor\n\n          const f =\n          /** @type {!Function} */\n          target.bind.apply(target, args);\n          return new f();\n        }\n\n        return target.apply(this, args);\n      };\n\n      isMethod = true;\n    } else if (target instanceof Array) {\n      proxy = [];\n      isArray = true;\n    } else {\n      proxy = canCreateNullProtoObjects || proto !== null ? objectCreate(proto) : {};\n    } // Create default getters/setters. Create different code paths as handler.get/handler.set can't\n    // change after creation.\n\n\n    const getter = handler.get ? function (prop) {\n      throwRevoked('get');\n      return handler.get(this, prop, proxy);\n    } : function (prop) {\n      throwRevoked('get');\n      return this[prop];\n    };\n    const setter = handler.set ? function (prop, value) {\n      throwRevoked('set');\n      const status = handler.set(this, prop, value, proxy); // TODO(samthor): If the calling code is in strict mode, throw TypeError.\n      // if (!status) {\n      // It's (sometimes) possible to work this out, if this code isn't strict- try to load the\n      // callee, and if it's available, that code is non-strict. However, this isn't exhaustive.\n      // }\n    } : function (prop, value) {\n      throwRevoked('set');\n      this[prop] = value;\n    }; // Clone direct properties (i.e., not part of a prototype).\n\n    const propertyNames = $Object.getOwnPropertyNames(target);\n    const propertyMap = {};\n    propertyNames.forEach(function (prop) {\n      if ((isMethod || isArray) && prop in proxy) {\n        return; // ignore properties already here, e.g. 'bind', 'prototype' etc\n      }\n\n      const real = $Object.getOwnPropertyDescriptor(target, prop);\n      const desc = {\n        enumerable: Boolean(real.enumerable),\n        get: getter.bind(target, prop),\n        set: setter.bind(target, prop)\n      };\n      $Object.defineProperty(proxy, prop, desc);\n      propertyMap[prop] = true;\n    }); // Set the prototype, or clone all prototype methods (always required if a getter is provided).\n    // TODO(samthor): We don't allow prototype methods to be set. It's (even more) awkward.\n    // An alternative here would be to _just_ clone methods to keep behavior consistent.\n\n    let prototypeOk = true;\n\n    if (isMethod || isArray) {\n      // Arrays and methods are special: above, we instantiate boring versions of these then swap\n      // our their prototype later. So we only need to use setPrototypeOf in these cases. Some old\n      // engines support `Object.getPrototypeOf` but not `Object.setPrototypeOf`.\n      const setProto = $Object.setPrototypeOf || ([].__proto__ === Array.prototype ? function setPrototypeOf(O, proto) {\n        validateProto(proto);\n        O.__proto__ = proto;\n        return O;\n      } : noop);\n\n      if (!(proto && setProto(proxy, proto))) {\n        prototypeOk = false;\n      }\n    }\n\n    if (handler.get || !prototypeOk) {\n      for (let k in target) {\n        if (propertyMap[k]) {\n          continue;\n        }\n\n        $Object.defineProperty(proxy, k, {\n          get: getter.bind(target, k)\n        });\n      }\n    } // The Proxy polyfill cannot handle adding new properties. Seal the target and proxy.\n\n\n    $Object.seal(target);\n    $Object.seal(proxy);\n    return proxy; // nb. if isMethod is true, proxy != this\n  };\n\n  ProxyPolyfill.revocable = function (target, handler) {\n    const p = new ProxyPolyfill(target, handler);\n    return {\n      'proxy': p,\n      'revoke': lastRevokeFn\n    };\n  };\n\n  return ProxyPolyfill;\n};","map":{"version":3,"sources":["C:/Users/multicampus/Desktop/2학기/2학기저장소/s03p13d203(sub3)/user-create-loginout/node_modules/proxy-polyfill/src/proxy.js"],"names":["module","exports","proxyPolyfill","lastRevokeFn","ProxyPolyfill","isObject","o","validateProto","proto","TypeError","$Object","Object","canCreateNullProtoObjects","Boolean","create","__proto__","objectCreate","SyntaxError","T","prototype","noop","getProto","getPrototypeOf","Array","O","target","handler","newTarget","constructor","undefined","throwRevoked","trap","setTimeout","unsafeHandler","k","apply","bind","proxy","isMethod","isArray","usingNew","args","slice","call","arguments","unshift","f","getter","get","prop","setter","set","value","status","propertyNames","getOwnPropertyNames","propertyMap","forEach","real","getOwnPropertyDescriptor","desc","enumerable","defineProperty","prototypeOk","setProto","setPrototypeOf","seal","revocable","p"],"mappings":"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","sourcesContent":["/*\n * Copyright 2016 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n * use this file except in compliance with the License. You may obtain a copy of\n * the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations under\n * the License.\n */\n\nmodule.exports = function proxyPolyfill() {\n  let lastRevokeFn = null;\n  let ProxyPolyfill;\n\n  /**\n   * @param {*} o\n   * @return {boolean} whether this is probably a (non-null) Object\n   */\n  function isObject(o) {\n    return o ? (typeof o === 'object' || typeof o === 'function') : false;\n  }\n\n  function validateProto(proto) {\n    if (proto !== null && !isObject(proto)) {\n      throw new TypeError('Object prototype may only be an Object or null: ' + proto);\n    }\n  }\n\n  const $Object = Object;\n\n  // Closure assumes that `{__proto__: null} instanceof Object` is always true, hence why we check against a different name.\n  const canCreateNullProtoObjects = Boolean($Object.create) || !({ __proto__: null } instanceof $Object);\n  const objectCreate =\n    $Object.create ||\n    (canCreateNullProtoObjects\n      ? function create(proto) {\n          validateProto(proto);\n          return { __proto__: proto };\n        }\n      : function create(proto) {\n          validateProto(proto);\n          if (proto === null) {\n            throw new SyntaxError('Native Object.create is required to create objects with null prototype');\n          }\n\n          // nb. cast to convince Closure compiler that this is a constructor\n          var T = /** @type {!Function} */ (function T() {});\n          T.prototype = proto;\n          return new T();\n        });\n\n  const noop = function() { return null; };\n\n  const getProto =\n    $Object.getPrototypeOf ||\n    ([].__proto__ === Array.prototype\n      ? function getPrototypeOf(O) {\n          // If O.[[Prototype]] === null, then the __proto__ accessor won't exist,\n          // as it's inherited from `Object.prototype`\n          const proto = O.__proto__;\n          return isObject(proto) ? proto : null;\n        }\n      : noop);\n\n  /**\n   * @constructor\n   * @param {!Object} target\n   * @param {{apply, construct, get, set}} handler\n   */\n  ProxyPolyfill = function(target, handler) {\n    const newTarget = this && this instanceof ProxyPolyfill ? this.constructor : undefined;\n    if (newTarget === undefined) {\n      throw new TypeError(\"Constructor Proxy requires 'new'\");\n    }\n\n    if (!isObject(target) || !isObject(handler)) {\n      throw new TypeError('Cannot create proxy with a non-object as target or handler');\n    }\n\n    // Construct revoke function, and set lastRevokeFn so that Proxy.revocable can steal it.\n    // The caller might get the wrong revoke function if a user replaces or wraps scope.Proxy\n    // to call itself, but that seems unlikely especially when using the polyfill.\n    let throwRevoked = function() {};\n    lastRevokeFn = function() {\n      /** @suppress {checkTypes} */\n      target = null;  // clear ref\n      throwRevoked = function(trap) {\n        throw new TypeError(`Cannot perform '${trap}' on a proxy that has been revoked`);\n      };\n    };\n    setTimeout(function() {\n      lastRevokeFn = null;\n    }, 0);\n\n    // Fail on unsupported traps: Chrome doesn't do this, but ensure that users of the polyfill\n    // are a bit more careful. Copy the internal parts of handler to prevent user changes.\n    const unsafeHandler = handler;\n    handler = { 'get': null, 'set': null, 'apply': null, 'construct': null };\n    for (let k in unsafeHandler) {\n      if (!(k in handler)) {\n        throw new TypeError(`Proxy polyfill does not support trap '${k}'`);\n      }\n      handler[k] = unsafeHandler[k];\n    }\n    if (typeof unsafeHandler === 'function') {\n      // Allow handler to be a function (which has an 'apply' method). This matches what is\n      // probably a bug in native versions. It treats the apply call as a trap to be configured.\n      handler.apply = unsafeHandler.apply.bind(unsafeHandler);\n    }\n\n    // Define proxy as an object that extends target.[[Prototype]],\n    // or a Function (if either it's callable, or apply is set).\n    const proto = getProto(target);  // can return null in old browsers\n    let proxy;\n    let isMethod = false;\n    let isArray = false;\n    if (typeof target === 'function') {\n      proxy = function ProxyPolyfill() {\n        const usingNew = (this && this.constructor === proxy);\n        const args = Array.prototype.slice.call(arguments);\n        throwRevoked(usingNew ? 'construct' : 'apply');\n\n        // TODO(samthor): Closure compiler doesn't know about 'construct', attempts to rename it.\n        if (usingNew && handler['construct']) {\n          return handler['construct'].call(this, target, args);\n        } else if (!usingNew && handler.apply) {\n          return handler['apply'](target, this, args);\n        }\n\n        // since the target was a function, fallback to calling it directly.\n        if (usingNew) {\n          // inspired by answers to https://stackoverflow.com/q/1606797\n          args.unshift(target);  // pass class as first arg to constructor, although irrelevant\n          // nb. cast to convince Closure compiler that this is a constructor\n          const f = /** @type {!Function} */ (target.bind.apply(target, args));\n          return new f();\n        }\n        return target.apply(this, args);\n      };\n      isMethod = true;\n    } else if (target instanceof Array) {\n      proxy = [];\n      isArray = true;\n    } else {\n      proxy = (canCreateNullProtoObjects || proto !== null) ? objectCreate(proto) : {};\n    }\n\n    // Create default getters/setters. Create different code paths as handler.get/handler.set can't\n    // change after creation.\n    const getter = handler.get ? function(prop) {\n      throwRevoked('get');\n      return handler.get(this, prop, proxy);\n    } : function(prop) {\n      throwRevoked('get');\n      return this[prop];\n    };\n    const setter = handler.set ? function(prop, value) {\n      throwRevoked('set');\n      const status = handler.set(this, prop, value, proxy);\n      // TODO(samthor): If the calling code is in strict mode, throw TypeError.\n      // if (!status) {\n        // It's (sometimes) possible to work this out, if this code isn't strict- try to load the\n        // callee, and if it's available, that code is non-strict. However, this isn't exhaustive.\n      // }\n    } : function(prop, value) {\n      throwRevoked('set');\n      this[prop] = value;\n    };\n\n    // Clone direct properties (i.e., not part of a prototype).\n    const propertyNames = $Object.getOwnPropertyNames(target);\n    const propertyMap = {};\n    propertyNames.forEach(function(prop) {\n      if ((isMethod || isArray) && prop in proxy) {\n        return;  // ignore properties already here, e.g. 'bind', 'prototype' etc\n      }\n      const real = $Object.getOwnPropertyDescriptor(target, prop);\n      const desc = {\n        enumerable: Boolean(real.enumerable),\n        get: getter.bind(target, prop),\n        set: setter.bind(target, prop),\n      };\n      $Object.defineProperty(proxy, prop, desc);\n      propertyMap[prop] = true;\n    });\n\n    // Set the prototype, or clone all prototype methods (always required if a getter is provided).\n    // TODO(samthor): We don't allow prototype methods to be set. It's (even more) awkward.\n    // An alternative here would be to _just_ clone methods to keep behavior consistent.\n    let prototypeOk = true;\n    if (isMethod || isArray) {\n      // Arrays and methods are special: above, we instantiate boring versions of these then swap\n      // our their prototype later. So we only need to use setPrototypeOf in these cases. Some old\n      // engines support `Object.getPrototypeOf` but not `Object.setPrototypeOf`.\n      const setProto =\n        $Object.setPrototypeOf ||\n        ([].__proto__ === Array.prototype\n          ? function setPrototypeOf(O, proto) {\n              validateProto(proto);\n              O.__proto__ = proto;\n              return O;\n            }\n          : noop);\n      if (!(proto && setProto(proxy, proto))) {\n        prototypeOk = false;\n      }\n    }\n    if (handler.get || !prototypeOk) {\n      for (let k in target) {\n        if (propertyMap[k]) {\n          continue;\n        }\n        $Object.defineProperty(proxy, k, { get: getter.bind(target, k) });\n      }\n    }\n\n    // The Proxy polyfill cannot handle adding new properties. Seal the target and proxy.\n    $Object.seal(target);\n    $Object.seal(proxy);\n\n    return proxy;  // nb. if isMethod is true, proxy != this\n  };\n\n  ProxyPolyfill.revocable = function(target, handler) {\n    const p = new ProxyPolyfill(target, handler);\n    return { 'proxy': p, 'revoke': lastRevokeFn };\n  };\n\n  return ProxyPolyfill;\n}\n"]},"metadata":{},"sourceType":"script"}